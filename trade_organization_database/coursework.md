# МИНИСТЕРСТВО ОБРАЗОВАНИЯ, НАУКИ И МОЛОДЁЖНОЙ ПОЛИТИКИ РЕСПУБЛИКИ КОМИ

Государственное профессиональное образовательное учреждение
"Сыктывкарский политехнический техникум"

## Курсовая работа

Тема: База данных торговой организации

**Профессия / специальность**

Информационные системы и программирование

**Выполнил**

Анчиков Антон Дмитриевич

Дневная, 4 курс, 414гр.

**Руководитель**

Пунгин И.В.

## Задание на курсовую работу по МДК 11.01 "Технология разработки и защиты баз данных"

Специальность: 09.02.07 "Информационные системы и программирование"

Тема курсовой работы: База данных торговой организации

Срок представления работы к защите: Апрель 2025 года.

### <a id="content">Содержание</a>

1. [Введение](#introduction)
    - [Цель работы](#target)
    - [Задачи работы](#tasks)
2. [Основная часть](#main)
    - [Анализ предметной области. Постановка задачи](#analysis)
    - [Инфологическая (концептуальная) модель базы данных](#Infological_model)
    - [Логическая структура БД](#Logical_structure)
    - [Физическая структура базы данных](#Physical_scructure)
    - [Реализация проекта в среде конкретной СУБД](#Project_realization)
3. [Заключение](#Conclusion)

### <a id="introduction">Введение</a>

В современных торговых организациях управление данными играет ключевую роль в обеспечении эффективности и конкурентоспособности. Успешная деятельность требует систематизации информации о товарах, поставщиках, клиентах и продажах. Ручное введение учёта уже не способно справляться с растущими объёмами данных, что приводит к ошибкам, потерям времени и снижению качества обслуживания клиентов. Поэтому создание автоматизированной базы данных становится важной задачей для торговой организации, так как оно обеспечивает быструю обработку данных и повышает точность учёта.

В данной работе рассматривается процесс разработки базы данных для торговой организации, целью которой является создание надёжного и функционального инструмента для хранения и управления данными о продажах, товарах и клиентах. Такой подход позволит улучшить контроль за операциями, сократить временные затраты на обработку информации и повысить общую продуктивность работы организации.

#### <a id="target">Цель работы</a>

Целью курсовой работы является разработка базы данных, которая автоматизирует процессы учёта и анализа данных в торговой организации. База данных должна позволять вести учёт товаров, отслеживать информацию о клиентах и продажах, а также формировать отчёты по различным показателям.

#### <a id="tasks">Задачи работы</a>

Для достижения поставленной цели необходимо решить следующие задачи:

1. **Анализировать деятельность торговой организации** для выявления основных требований к базе данных и объёма данных, подлежащих хранению и обработке.
2. **Проектировать структуру базы данных**, включающую ключевые таблицы, атрибуты и связи между сущностями, такими как товары, клиенты, поставщики и продажи.
3. **Выбрать и обосновать систему управления базами данных (СУБД)**, которая будет использована для реализации проекта (например, MySQL или PostgreSQL).
4. **Реализовать структуру базы данных** на выбранной СУБД, включая создание таблиц и связей с помощью SQL-запросов.
5. **Заполнить базу данных тестовыми данными** для проверки работоспособности и корректности структуры.
6. **Разработать и протестировать SQL-запросы** для получения необходимых данных, таких как выборка товаров, регистрация продаж и анализ покупок.
7. **Осуществить тестирование базы данных** для проверки корректности выполнения всех операций, целостности данных и функциональности запросов.
8. **Сформулировать выводы и предложения** по дальнейшему развитию и расширению функционала базы данных.

Эти задачи направлены на создание эффективного инструмента, который позволит торговой организации упорядочить свои данные, автоматизировать ключевые процессы и облегчить доступ к информации.

[Вернуться к содержанию](#content)

### <a id="main">Основная часть</a>

#### <a id="analysis">Анализ предметной области. Постановка задачи</a>

1. **Описание предметной области и функции решаемых задач**
    - **Предметная область** данной работы - торговая организация, занимающаяся продажей товаров. Организация стремится автоматизировать процессы учёта товаров, отслеживания продаж и взаимодействия с клиентами и поставщиками. Цель автоматизации - упрощение работы с данными и повышение эффективности работы.
    - **Функции решаемых задач:**
        - **Учёт товаров:** Ведение базы данных с описанием каждого наименования (название, категория, цена, количество на складе). Это позволит менеджерам видеть актуальную информацию о наличии товаров и планировать заказы на пополнение.
        - **Регистрация продаж:** Запись данных о каждой продаже, включая дату, товар, количество и сумму. Это даст возможность анализировать продажи, расчитывать выручку и оценивать спрос на товары.
        - **Учёт клиентов и поставщиков:** Сохранение данных о клиентах и поставщиках, включая контактную информацию и историю взаимодействия. Это позволяет автоматизировать учёт клиентов и упростить работу с поставщиками.
        - **Формирование отчётов:** Генерация отчётов на основе данных, содержащиеся в базе, таких как списки товаров с их количеством на складе, отчёты по продажам за определённые периоды, информацию о наиболее и наименее популярных товарах.
2. **Перечень входных данных.** Для эффективной работы системы необходимы следующие входные данные:
    - **Товары:**
        - Идентификатор товара (ID).
        - Название товара.
        - Категория (например, одежда, техника, продукты).
        - Цена за единицу товара.
        - Количество на складе.
    - **Клиенты:**
        - Индентификатор клиента (ID).
        - ФИО
        - Контактная информация (номер телефона, электронная почта).
        - История покупок (дата, товары, сумма покупки).
    - **Поставщики:**
        - Идентификатор поставщика (ID).
        - Название компании.
        - Контактная информация (номер телефона, электронная почта).
        - Ассортимент поставляемых товаров.
    - **Продажи:**
        - Идентификатор продажи (ID).
        - Дата и время продажи.
        - Идентификатор клиента.
        - Список проданных товаров (товары, количество, цена за товар, итоговая сумма).
3. **Перечень выходных данных.** На основе входных данных система должна предоставить следующие выходные данные:
    - **Отчёт по товарам:**
        - Список товаров с текущим количеством на складе.
        - Сведения о товарах, требующих пополнения запасов.
        - Перечень товаров по категориям и по стоимости.
    - **Отчёты по продажам:**
        - Сумма продаж за определённый срок (день, неделя, месяц).
        - Данные о наиболее популярных товарах (сортировка по количеству проданных единиц).
        - Сводка по продажам для конкретного клиента.
    - **Отчёт по клиентам и поставщикам:**
        - Список активных клиентов и их контактные данные.
        - История покупок конкретного клиента.
        - Информация о поставщиках с ассортиментом предоставляемых товаров и контактной информации.
4. **Ограничения предметной области.** При работе с базой данных могут возникнуть следующие ограничения:
    - **Ограничение по объёму данных:** Если количество товаров, клиентов или данных о продажах существенно возрастёт, это может негативно сказаться на скорости обработки запросов. Необходимо учитывать возможность оптимизации базы данных и использования индексации для ускорения обработки больших объёмов данных.
    - **Ограничение по доступу:** Данные, такие как личная информация о клиентах или данные о продажах, должны быть защищены от несанкционированного доступа. Это ограничение требует реализации надёжных механизмов авторизации и разграничения прав пользователей.
    - **Ограничение по обновлению данных:** Чтобы избежать потери данных, необходимо разработать систему резервного копирования. Это ограничение предполагает наличие регулярных бэкапов для предотвращения потерь информации в случае технических сбоев.
5. **Взаимодействие с другими программами.** База данных торговой организации может взаимодействовать с различными программами и модулями для расширения функциональности и повышения удобства работы:
    - **Программа для бухгалтерского учёта:** Автоматизация передачи данных о продажах в систему учёта поможет ускорить процесс финансовой отчётности и исключить возможные ошибки.
    - **CRM-система:** Интерграция с системой управления клиентами (Customer Relationship Management) позволит более эффективно работать с клиентами, вести их историю и предлагать персонализированнные предложения.
    - **Интернет-магазин:** Если торговая организация продаёт товары онлайн, база данных может быть интегрирована с сайтом или приложением, что позволит автоматически обновлять информацию о наличии товаров на складе и регистрировать заказы.
    - **Система аналитики:** Для анализа данных и визуализации отчётов можно интегрировать базу данных с аналитическими платформами (например, Power BI или Google Data Studio), что поможет строить более глубокий анализ показателей и получать наглядные отчёты.

[Вернуться к содержанию](#content)

#### <a id="Infological_model">Инфологическая (концептуальная) модель базы данных</a>

Концептуальная модель базы данных описывает структуру данных, которая будет храниться и обрабатываться в базе, без привязки к конкретной системе управления базами данных (СУБД). В рамках этой модели выделяются ключевые информационные объекты, атрибуты этих объектов, связи между ними, а также мощности отношений, которые определяют тип связей между сущностями.

1. **Выделение информационных объектов.** На основе анализа бизнес-процессов торговой организации выделяются следующие информационные объекты:
    - **Товар** - информация о товарах, представленных в ассортименте организации.
    - **Категория** - класс или группа товаров, объединённых по определенному признаку.
    - **Клиент** - данные о покупателях, которые совершают покупки в организации.
    - **Поставщик** - данные о компаниях или лицах, поставляющих товары для организации.
    - **Продажа** - информация о транзакциях, отражающих продажу товаров клиентам.
    - **Состав продажи** - детализация конкретной продажи, включающая сведения о каждом проданном товаре, его количестве и стоимости.
2. **Определение атрибутов объектов.** Каждая из выделенных сущностей имеют свои уникальные атрибуты, которые описывают их свойства.
    - **Товар:**
        - ID_товара (уникальный идентификатор).
        - Название товара.
        - Цена.
        - Количество на складе.
        - ID_категории (ссылка на категорию товара).
        - ID_поставщика (ссылка на поставщика товара).
        - Описание (дополнительная информация о товаре).
    - **Категория:**
        - ID_категории (уникальный идентификатор).
        - Название категории.
    - **Клиент:**
        - ID_клиента (уникальный идентификатор).
        - ФИО.
        - Телефон.
        - Электронная почта.
        - Адрес проживания.
    - **Поставщик:**
        - ID_поставщика (уникальный идентификатор).
        - Название компании.
        - Телефон.
        - Электронная почта.
    - **Продажа:**
        - ID_продажи (уникальный идентификатор).
        - Дата и время продажи.
        - ID_клиента (уникальный идентификатор).
        - Общая сумма.
    - **Состав продажи:**
        - ID_позиции (уникальный идентификатор).
        - ID_продажи (уникальный идентификатор).
        - ID_товара (уникальный идентификатор).
        - Количество.
        - Цена.
3. **Определение отношений и мощности отношений между объектами.** Определим связи и мощности отношений между выделенными сущностями:
    - **Категория - Товар:**
        - **Связь:** один ко многим.
        - **Описание:** Каждая категория может содержать множество товаров, но каждый товар относится только к одной категории.
    - **Клиент - Продажа:**
        - **Связь:** один ко многим.
        - **Описание:** Один клиент может совершать множество покупок (продаж), но каждая продажа привязана только к одному клиенту.
    - **Поставщик - Товар:**
        - **Связь:** один ко многим.
        - **Описание:** Один поставщик может поставлять множество товаров, но каждый товар закупается только у одного поставщика.
    - **Продажа - Состав продажи:**
        - **Связь:** один ко многим.
        - **Описание:** Одна продажа может содержать несколько позиций (товаров), но каждая позиция связана с конкретной продажей.
    - **Товар - Состав продажи:**
        - **Связь:** один ко многим.
        - **Описание:** Один товар может участвовать в различных продажах, но каждая запись о товаре относится к одной позиции в определённой продаже.
4. **Построение концептуальной модели.** На основе выделенных сущностей, их атрибутов и связей между ними можно построить концепуальную ER-диаграмму. Концептуальная модель будет включать следующие элементы:
    - **Категория** (ID_категории, название категории), связана с **Товаром** (ID_товара, название, цена, количество на складе, ID_категории, описание).
    - **Клиент** (ID_клиента, ФИО, телефон, электронная почта, адрес проживания), связан с **Продажей** (ID_продажи, дата и время продажи, ID_клиента, общая сумма).
    - **Поставщик** (ID_поставщика, название компании, телефон, электронная почта), связан с **Товаром** через отношение "один ко многим".
    - **Продажа** (ID_продажи, дата и время продажи, ID_клиента, общая сумма), связана с **Составом продажи** (ID_позиции, ID_продажи, ID_товара, количество, цена).
    - **Состав продажи** связан с **Товаром** через ID_товара для указания конкретного товара в продаже и его количества.

[Вернуться к содержанию](#content)

#### <a id="Logical_structure">Логическая структура базы данных</a>

Логическая структура базы данных представляет собой детализированное описание таблиц, их атрибутов, типов данных, связей между таблицами, а также ключевых ограничений и правил целостности. На основе концептуальной модели можно построить логическую структуру, которая будет готова для реализации в системе управления базами данных (СУБД).

В данной структуре будут определены следующие таблицы: **Товары**, **Категории**, **Клиенты**, **Поставщики**, **Продажи**, **Состав продажи**, а также связи между ними.

**Определение таблиц и их атрибутов**

1. **Таблица "Категории"**
    - **ID_категории** (Primary Key) - уникальный идентификатор категории товаров (целое число).
    - **Название категории** - наименование категории товара (строка).

    **Типы данных:**
    - ID_категории - INT.
    - Название категории - VARCHAR(255).

    **Ограничения:**
    - ID_категории является уникальным и не может быть NULL.
2. **Таблица "Товары"**
    - **ID_товара** (Primary Key) - уникальный идентификатор товара (целое число).
    - **Название** - название товара (строка).
    - **Цена** - цена товара (десятичное число с двумя знаками после запятой).
    - **Количество на складе** - количество товара на складе (целое число).
    - **ID_категории** (Foreign Key) - ссылка на таблицу **Категории** (целое число).
    - **ID_поставщика** (Foreign Key) - ссылка на таблицу **Поставщики** (целое число).
    - **Описание** - описание товара (строка).

    **Типы данных:**
    - **ID_товара** - INT.
    - **Название** - VARCHAR(255).
    - **Цена** - DECIMAL(10,2).
    - **Количество на складе** - INT.
    - **ID_категории** - INT.
    - **ID_поставщика** - INT.
    - **Описание** - VARCHAR(255).

    **Ограничения:**
    - ID_товара является уникальным и не может быть NULL.
    - ID_категории является внешним ключом, который ссылается на таблицу **Категории**.
    - ID_поставщика является внешним ключом, который ссылается на таблицу **Поставщики**
3. **Таблица "Клиенты"**
    - **ID_клиента** (Primary Key) - уникальный идентификатор клиента (целое число).
    - **ФИО** - фамилия, имя и отчество клиента (строка).
    - **Телефон** - номер телефона клиента (строка).
    - **Электронная почта** - email клиента (строка).
    - **Адрес проживания** - адрес клиента (строка).

    **Типы данных:**
    - **ID_клиента** - INT.
    - **ФИО** - VARCHAR(255).
    - **Телефон** - VARCHAR(20).
    - **Электронная почта** - VARCHAR(255).
    - **Адрес проживания** - VARCHAR(255).

    **Ограничения:**
    - ID_клиента является уникальным и не может быть NULL.
4. **Таблица "Поставщики"**
    - **ID_поставщика** (Primary Key) - уникальный идентификатор поставщика (целое число).
    - **Название компании** - наименование компании поставщика (строка).
    - **Телефон** - контактный телефон поставщика (строка).
    - **Электронная почта** - email поставщика (строка).

    **Типы данных:**
    - **ID_поставщика** - INT.
    - **Название компании** - VARCHAR(255).
    - **Телефон** - VARCHAR(20).
    - **Электронная почта** - VARCHAR(255).

    **Ограничения:**
    - ID_поставщика является уникальным и не может быть NULL.
5. **Таблица "Продажи"**
    - **ID_продажи** (Primary Key) - уникальный идентификатор продажи (целое число).
    - **Дата и время продажи** - дата и время продажи (DATETIME).
    - **ID_клиента** (Foreign Key) - ссылка на клиента, совершившего покупку (целое число).
    - **Общая сумма** - общая сумма продажи (десятичное число с двумя знаками после запятой).

    **Типы данных:**
    - **ID_продажи** - INT.
    - **Дата и время продажи** - DATETIME.
    - **ID_клиента** - INT.
    - **Общая сумма** - DECIMAL(10,2).

    **Ограничения:**
    - ID_продажи является уникальным и не может быть NULL.
    - ID_клиента является внешним ключом, который ссылается на таблицу **Клиенты**.
6. **Таблица "Состав продажи"**
    - **ID_позиции** (Primary Key) - уникальный идентификатор позиции в продаже (целое число).
    - **ID_продажи** (Foreign Key) - ссылка на таблицу **Продажи** (целое число).
    - **ID_товара** (Foreign Key) - ссылка на таблицу **Товары** (целое число).
    - **Количество** - количество проданных единиц товара (целое число).
    - **Цена** - цена товара на момент продажи (десятичное число с двумя знаками после запятой).

    **Типы данных:**
    - **ID_позиции** - INT.
    - **ID_продажи** - INT.
    - **ID_товара** - INT.
    - **Количество** - INT.
    - **Цена** - DECIMAL(10,2).

    **Ограничения:**
    - ID_позиции является уникальным и не может быть NULL.
    - ID_продажи является внешним ключом, который ссылается на таблицу **Продажи**.
    - ID_товара является внешним ключом, который ссылается на таблицу **Товары**.

**Определение связей между таблицами**

1. **Категория - Товар:**
    - **Один ко многим.** Одна категория может содержать множество товаров, но каждый товар относится только к одной категории.
    - Реализуется через атрибут **ID_категории** в таблице **Товары**, который ссылается на таблицу **Категории**.
2. **Клиент - Продажа:**
    - **Один ко многим.** Один клиент может совершать множество покупок (продаж), но каждая продажа привязана только к одному клиенту.
    - Реализуется через атрибут **ID_клиента** в таблице **Продажи**, который ссылается на таблицу **Клиенты**.
3. **Поставщик - Товар:**
    - **Один ко многим.** Один поставщик может поставлять множество товаров, но каждый товар закупается только у одного поставщика.
    - Реализуется через атрибут **ID_поставщика** в таблице **Товары**, который ссылается на таблицу **Поставщики**.
4. **Продажа - Состав продажи:**
    - **Один ко многим.** Одна продажа может включать множество позиций (товаров), но каждая позиция связана с одной продажей.
    - Реализуется через атрибут **ID_продажи** в таблице **Состав продажи**, который ссылается на таблицу **Продажи**.
5. **Товар - Состав продажи:**
    - **Один ко многим.** Один товар может быть продан в разных позициях продаж, но каждая позиция в продаже включает только один товар.
    - Реализуется через атрибут **ID_товара** в таблице **Состав продажи**, который ссылается на таблицу **Товары**.

**Нормализация базы данных**

На данном этапе структура базы данных приведена к третьей нормальной форме (3NF), что позволяет:

- Устранить избыточность данных.
- Избежать аномалий при добавлении, изменении и удалении данных.
- Обеспечить более эффективное использование памяти и более быструю обработку запросов.

[Вернуться к содержанию](#content)

#### <a id="Physical_scructure">Физическая структура базы данных</a>

Физическая структура базы данных отвечает за реальное хранение данных на физическом уровне, определяет способы хранения и работы с данными, обеспечивая при этом их целостность, доступность и производительность системы. На этом этапе важно учитывать оптимизацию производительности запросов, объёмы данных и ограничения, связанные с физическим хранением данных в выбранной СУБД. В данной курсовой работе предполагается использование реляционной СУБД (PostgreSQL), так как они предоставляют оптимальные средства для управления табличными данными и поддерживают сложные связи между данными, что необходимо для торговой организации.

Физическая структура проектируется таким образом, чтобы система максимально эффективно обрабатывала данные, предоставляя пользователю доступ к нужной информации с минимальной задержкой. Это достигается с помощью выбора правильных типов данных, индексов, механизмов хранения и настройки параметров, обеспечивающих производительность и надежность.

1. **Выбор типов данных**

Правильный выбор типов данных для полей таблиц — один из ключевых аспектов проектирования физической структуры базы данных, так как это позволяет экономить ресурсы и повышать производительность.

**Рассмотрим выбор типов данных для каждой таблицы:**

- **INT** — используется для целочисленных значений, таких как идентификаторы записей. INT занимает фиксированный объем памяти и обеспечивает эффективное индексирование, что важно для первичных и внешних ключей. Это подходит для полей, которые используются как ключи и часто участвуют в соединениях и фильтрации данных.
- **VARCHAR(255)** — применяется для хранения текстовых данных переменной длины, таких как имена, контактная информация, названия и описания. Этот тип позволяет оптимально расходовать память, так как фактически занимает объем, соответствующий реальной длине строки. Например, для имени клиента поле может содержать от 1 до 255 символов.
- **DECIMAL(10,2)** — используется для чисел с фиксированной точностью, например, для хранения цен товаров и суммы продажи. Этот тип данных позволяет избежать проблем, связанных с округлением, и необходим для денежных значений, требующих высокой точности.
- **TIMESTAMP** — используется для временных отметок, которые необходимы для регистрации дат и времени. В системе для торговой организации это важно для учета продаж, поставок и других событий, привязанных ко времени.

Тип данных влияет на объем занимаемой памяти и производительность базы данных, так как данные записываются и извлекаются в зависимости от того, какой тип используется. Правильный выбор типа данных также облегчает работу СУБД с индексами и улучшает время выполнения запросов.

**Пример SQL-кода с применением типов данных для таблицы "Продажи":**

```
CREATE TABLE Продажи (
    ID_продажи INT PRIMARY KEY AUTO_INCREMENT,
    Дата_продажи DATETIME NOT NULL,
    ID_клиента INT,
    Общая_сумма DECIMAL(10,2),
    FOREIGN KEY (ID_клиента) REFERENCES Клиенты(ID_клиента)
);
```

2. **Оптимизация индексов**

Индексы являются ключевым элементом в оптимизации базы данных, так как они позволяют ускорить доступ к данным и облегчают выполнение запросов, таких как поиск, фильтрация и сортировка. Индексы создаются для полей, которые часто участвуют в поисковых запросах и соединениях таблиц. В физической структуре базы данных индексы устанавливаются на ключевых полях:

- **Первичные ключи** автоматически индексируются, так как они служат для уникальной идентификации каждой записи. Это гарантирует быстрое выполнение операций поиска и обновления записей.
- **Внешние ключи** (например, ID_категории, ID_поставщика, ID_клиента) также индексируются, чтобы ускорить выполнение соединений между таблицами. Внешние ключи позволяют поддерживать целостность данных, предотвращая создание записей, не соответствующих связанным данным.
- **Дополнительные индексы** — в зависимости от анализа предполагаемых запросов можно добавить индексы для часто запрашиваемых полей, например, для поля Дата_продажи в таблице Продажи, если предполагается, что пользователи часто будут искать продажи по дате.

**Создание индексов:**

```
CREATE INDEX idx_товары_категория ON Товары (ID_категории);
CREATE INDEX idx_товары_поставщик ON Товары (ID_поставщика);
CREATE INDEX idx_продажи_дата ON Продажи (Дата_продажи);
```

**Преимущества индексов:**

- Ускоряют поиск и сортировку.
- Повышают производительность запросов с условиями фильтрации.
- Уменьшают время выполнения операций соединения.

3. **Таблицы и кластеризация данных**

Кластеризация позволяет физически упорядочивать записи на диске по значению индекса, что может существенно ускорить выполнение запросов, в которых данные фильтруются и сортируются по определенному столбцу. Например, таблицу **Состав_продажи** можно упорядочить по **ID_продажи**, чтобы данные одной продажи находились физически рядом. Это улучшает производительность запросов, касающихся конкретной продажи, так как чтение данных с диска выполняется быстрее.

Кластеризация часто используется для таблиц, где данные периодически обновляются, и доступ к этим данным требуется в соответствии с определенным критерием, как в нашем случае с ID_продажи.

4. **Механизм хранения и параметры оптимизации**

PostgreSQL использует механизм хранения данных, поддерживающий многоверсионность (MVCC, Multiversion Concurrency Control), что позволяет эффективно управлять транзакциями и конкурентным доступом к данным. В отличие от MySQL, PostgreSQL не требует явного указания механизма хранения при создании таблиц, так как все таблицы автоматически используют встроенный механизм. Этот механизм обеспечивает высокий уровень надежности, особенно для данных, подверженных частым изменениям, и поддерживает управление транзакциями, что критично для точности и согласованности данных.

**Преимущества MVCC в PostgreSQL для базы данных торговой организации:**

- **Поддержка транзакций** — гарантирует согласованность данных, например, при записи продаж и их составных частей. Каждая транзакция выполняется как отдельная операция, и в случае неудачи все изменения отменяются.
- **Конкурентный доступ** — PostgreSQL позволяет нескольким пользователям одновременно работать с данными, обеспечивая при этом изоляцию транзакций, что делает его особенно подходящим для высоконагруженных приложений, где требуется частое обновление данных.
- **Гибкое управление блокировками** — позволяет предотвращать конфликты между транзакциями и поддерживает высокую производительность.

**Пример создания таблицы в PostgreSQL:**

```
CREATE TABLE Товары (
    ID_товара SERIAL PRIMARY KEY,
    Название VARCHAR(255) NOT NULL,
    Цена NUMERIC(10, 2) NOT NULL CHECK (Цена >= 0),
    Количество_на_складе INT NOT NULL CHECK (Количество_на_складе >= 0),
    ID_категории INT,
    ID_поставщика INT,
    Описание TEXT,
    FOREIGN KEY (ID_категории) REFERENCES Категории(ID_категории),
    FOREIGN KEY (ID_поставщика) REFERENCES Поставщики(ID_поставщика)
);
```

**Особенности PostgreSQL при создании таблиц:**

- **Тип SERIAL** — используется для создания автоинкрементных первичных ключей. В PostgreSQL SERIAL автоматически создает последовательность и обеспечивает уникальные значения для каждого нового элемента, что упрощает настройку первичных ключей.
- **CHECK-ограничения** — PostgreSQL поддерживает гибкие ограничения, которые помогают контролировать значения в полях. Например, ограничения на поля **Цена** и **Количество_на_складе** гарантируют, что значения не будут отрицательными.

5. **Политики управления целостностью данных**

PostgreSQL предоставляет богатый функционал для поддержания целостности данных с использованием различных ограничений и ключей. Эти механизмы помогают гарантировать, что база данных всегда находится в согласованном состоянии.

**Основные элементы для управления целостностью:**

- **Первичные ключи (PRIMARY KEY)** — используются для уникальной идентификации записей в таблицах. В PostgreSQL первичные ключи создаются с использованием уникального индекса и автоматически проверяют уникальность значения.
- **Внешние ключи (FOREIGN KEY)** — обеспечивают целостность ссылочной структуры между таблицами. Внешние ключи используются, чтобы установить зависимость между записями. Например, в таблице **Товары** внешний ключ **ID_категории** гарантирует, что категория товара будет существовать в таблице **Категории**.
- **Ограничения NOT NULL** — применяются к полям, значения в которых обязательно должны быть указаны. Поля, такие как **Название** и **Цена**, не могут быть пустыми, так как эти данные являются обязательными для бизнес-процессов.
- **CHECK-ограничения** — применяются для контроля значений полей в соответствии с установленными правилами. Например, в поле **Количество_на_складе** вводятся только положительные значения, так как количество товара не может быть отрицательным. PostgreSQL позволяет создавать сложные ограничения, включая арифметические и логические проверки, что может быть полезным для более сложных условий.

```
CREATE TABLE Клиенты (
    ID_клиента SERIAL PRIMARY KEY,
    ФИО VARCHAR(255) NOT NULL,
    Телефон VARCHAR(20),
    Электронная_почта VARCHAR(255),
    Адрес VARCHAR(255),
    CHECK (Телефон ~ '^[0-9]+$')  -- Проверка, что телефон состоит только из цифр
);
```

В этом примере используется регулярное выражение для проверки, что телефон состоит только из цифр, что помогает поддерживать качество данных.

**Другие механизмы управления целостностью:**

- **Триггеры** — PostgreSQL поддерживает триггеры, которые позволяют выполнять дополнительные проверки и операции при добавлении, обновлении или удалении записей. Триггеры могут использоваться для автоматической записи истории изменений или для сложных проверок целостности, когда стандартных ограничений недостаточно.
- **Индексы** — PostgreSQL автоматически создает индексы для полей, которые заданы как первичные ключи или уникальные. Дополнительно можно добавлять индексы для часто используемых в запросах полей, таких как **Дата_продажи** в таблице **Продажи**. Это улучшает производительность запросов, так как индекс ускоряет поиск и доступ к данным.
- **Управление транзакциями** — PostgreSQL поддерживает уровни изоляции транзакций, которые позволяют определять правила работы с параллельными запросами. Например, для торговой базы данных это полезно при работе с запасами, когда одновременно выполняются несколько операций продажи и пополнения.

Таким образом, механизмы управления целостностью в PostgreSQL обеспечивают надежную работу базы данных, поддерживая высокую степень согласованности и производительности.

6. **Параметры хранения и резервное копирование**

Для обеспечения надежности базы данных торговой организации и защиты от потерь данных, в PostgreSQL необходимо организовать систему резервного копирования и продумать параметры хранения. PostgreSQL предлагает несколько методов резервного копирования и восстановления данных, а также настройки, которые влияют на производительность и безопасность системы.

**Резервное копирование**

PostgreSQL поддерживает два основных типа резервного копирования:

- **Логическое резервное копирование** — выполняется с помощью утилиты pg_dump. Этот метод позволяет копировать структуру и данные одной или нескольких баз данных. Логическое копирование используется в ситуациях, когда требуется гибкость, например, для восстановления на другой версии PostgreSQL или для миграции данных.

Пример использования pg_dump для создания резервной копии:

```
pg_dump -U username -F c -b -v -f "backup_filename.backup" database_name
```

Этот скрипт сохраняет базу данных в формате архивного файла, который затем можно будет использовать для восстановления.

- **Физическое резервное копирование** — выполняется путем копирования файлов данных на уровне файловой системы. PostgreSQL предоставляет инструмент pg_basebackup, который выполняет копирование всех файлов базы данных и создаёт полную копию в заданном каталоге.

Пример использования pg_basebackup:

```
pg_basebackup -U postgres -D /path/to/backup -Ft -z -P
```

Физическое резервное копирование особенно полезно для больших баз данных и высоконагруженных систем, так как оно позволяет быстрее восстанавливать данные и поддерживать согласованность на уровне файлов.

7. **Примерный SQL-код создания таблиц с физической структурой для PostgreSQL**

В этом разделе приводится полный пример SQL-кода для создания таблиц, описанных в предыдущих разделах. Каждая таблица строится с учетом требований физической структуры базы данных и с использованием всех механизмов PostgreSQL для оптимизации, поддержки целостности и обеспечения надежности данных.

```
-- Таблица для хранения информации о категориях товаров
CREATE TABLE Категории (
    ID_категории SERIAL PRIMARY KEY,
    Название_категории VARCHAR(255) NOT NULL
);

-- Таблица для информации о поставщиках
CREATE TABLE Поставщики (
    ID_поставщика SERIAL PRIMARY KEY,
    Название_поставщика VARCHAR(255) NOT NULL,
    Телефон VARCHAR(20),
    Электронная_почта VARCHAR(255),
    Адрес VARCHAR(255)
);

-- Таблица для хранения товаров
CREATE TABLE Товары (
    ID_товара SERIAL PRIMARY KEY,
    Название VARCHAR(255) NOT NULL,
    Цена NUMERIC(10,2) NOT NULL CHECK (Цена >= 0),
    Количество_на_складе INT NOT NULL CHECK (Количество_на_складе >= 0),
    ID_категории INT REFERENCES Категории(ID_категории),
    ID_поставщика INT REFERENCES Поставщики(ID_поставщика),
    Описание TEXT
);

-- Таблица для хранения данных о клиентах
CREATE TABLE Клиенты (
    ID_клиента SERIAL PRIMARY KEY,
    ФИО VARCHAR(255) NOT NULL,
    Телефон VARCHAR(20) CHECK (Телефон ~ '^[0-9]+$'),
    Электронная_почта VARCHAR(255),
    Адрес VARCHAR(255)
);

-- Таблица для данных о продажах
CREATE TABLE Продажи (
    ID_продажи SERIAL PRIMARY KEY,
    Дата_продажи TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ID_клиента INT REFERENCES Клиенты(ID_клиента),
    Общая_сумма NUMERIC(10,2) NOT NULL CHECK (Общая_сумма >= 0)
);

-- Таблица для состава продажи
CREATE TABLE Состав_продажи (
    ID_позиции SERIAL PRIMARY KEY,
    ID_продажи INT REFERENCES Продажи(ID_продажи) ON DELETE CASCADE,
    ID_товара INT REFERENCES Товары(ID_товара),
    Количество INT NOT NULL CHECK (Количество > 0),
    Цена NUMERIC(10,2) NOT NULL CHECK (Цена >= 0)
);

-- Индексы для оптимизации запросов
CREATE INDEX idx_товары_категория ON Товары (ID_категории);
CREATE INDEX idx_продажи_дата ON Продажи (Дата_продажи);
CREATE INDEX idx_клиенты_телефон ON Клиенты (Телефон);
```

**Описание и обоснование SQL-кода**

- **Создание таблиц:** Каждая таблица создается с использованием типа SERIAL для первичного ключа, который обеспечивает автоинкремент и уникальность записи. Поля, содержащие важные текстовые данные, используются с типом VARCHAR, а для денежных значений и количества применяется тип NUMERIC с точностью для контроля значений.
- **Ограничения целостности:** В таблицах установлены внешние ключи для обеспечения ссылочной целостности. Например, ID_категории и ID_поставщика в таблице Товары ссылаются на таблицы Категории и Поставщики. Это гарантирует, что данные будут структурированы и подчинены бизнес-логике системы.
- **Индексы:** Добавлены индексы для полей, которые часто участвуют в запросах. Например, idx_товары_категория для ускорения фильтрации и поиска товаров по категориям, а также idx_продажи_дата для ускорения выборок по дате продаж.
- **CHECK-ограничения:** Дополнительные ограничения установлены на такие поля, как Цена, Количество, чтобы защитить базу данных от некорректных значений и обеспечить соответствие данных бизнес-логике.

Этот SQL-код и структура таблиц обеспечивают надежную физическую реализацию базы данных в PostgreSQL для торговой организации, удовлетворяя всем требованиям по целостности, производительности и масштабируемости.

[Вернуться к содержанию](#content)

#### <a id="Project_realization">Реализация проекта в среде конкретной СУБД</a>

Этот раздел курсовой работы описывает практическую реализацию базы данных торговой организации в PostgreSQL. Рассматриваются основные этапы — от создания таблиц и запросов до разработки интерфейса и настройки прав доступа, индексов и резервного копирования.

1. **Создание таблиц**

Таблицы создаются на основе физической структуры, разработанной в предыдущих разделах. Ниже приводится SQL-код для создания основных таблиц.

```
-- Создание таблицы Категории
CREATE TABLE Категории (
    ID_категории SERIAL PRIMARY KEY,
    Название_категории VARCHAR(255) NOT NULL
);

-- Создание таблицы Поставщики
CREATE TABLE Поставщики (
    ID_поставщика SERIAL PRIMARY KEY,
    Название_поставщика VARCHAR(255) NOT NULL,
    Телефон VARCHAR(20),
    Электронная_почта VARCHAR(255),
    Адрес VARCHAR(255)
);

-- Создание таблицы Товары
CREATE TABLE Товары (
    ID_товара SERIAL PRIMARY KEY,
    Название VARCHAR(255) NOT NULL,
    Цена NUMERIC(10,2) NOT NULL CHECK (Цена >= 0),
    Количество_на_складе INT NOT NULL CHECK (Количество_на_складе >= 0),
    ID_категории INT REFERENCES Категории(ID_категории),
    ID_поставщика INT REFERENCES Поставщики(ID_поставщика),
    Описание TEXT
);

-- Создание таблицы Клиенты
CREATE TABLE Клиенты (
    ID_клиента SERIAL PRIMARY KEY,
    ФИО VARCHAR(255) NOT NULL,
    Телефон VARCHAR(20) CHECK (Телефон ~ '^[0-9]+$'),
    Электронная_почта VARCHAR(255),
    Адрес VARCHAR(255)
);

-- Создание таблицы Продажи
CREATE TABLE Продажи (
    ID_продажи SERIAL PRIMARY KEY,
    Дата_продажи TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ID_клиента INT REFERENCES Клиенты(ID_клиента),
    Общая_сумма NUMERIC(10,2) NOT NULL CHECK (Общая_сумма >= 0)
);

-- Создание таблицы Состав_продажи
CREATE TABLE Состав_продажи (
    ID_позиции SERIAL PRIMARY KEY,
    ID_продажи INT REFERENCES Продажи(ID_продажи) ON DELETE CASCADE,
    ID_товара INT REFERENCES Товары(ID_товара),
    Количество INT NOT NULL CHECK (Количество > 0),
    Цена NUMERIC(10,2) NOT NULL CHECK (Цена >= 0)
);
```

2. **Создание запросов**

Запросы для управления базой данных и получения информации помогут обеспечить работу торговой организации. Примеры запросов включают:

- **Вывод списка всех товаров по категориям с указанием цены и наличия:**

```
SELECT t.Название AS Товар, k.Название_категории AS Категория, t.Цена, t.Количество_на_складе
FROM Товары t
JOIN Категории k ON t.ID_категории = k.ID_категории;
```

- **Запрос для получения информации о клиентах и их последних покупках:**

```
SELECT c.ФИО, c.Телефон, p.Дата_продажи, p.Общая_сумма
FROM Клиенты c
JOIN Продажи p ON c.ID_клиента = p.ID_клиента
ORDER BY p.Дата_продажи DESC;
```

- **Запрос для получения общего дохода за период:**

```
SELECT SUM(Общая_сумма) AS Общий_доход
FROM Продажи
WHERE Дата_продажи BETWEEN '2024-01-01' AND '2024-12-31';
```

3. **Разработка интерфейса**

Интерфейс для взаимодействия с базой данных можно создать с использованием веб-технологий (например, HTML и JavaScript) или инструментов построения интерфейсов в Python, таких как tkinter. **Основные функции интерфейса должны включать:**

- **Отображение товаров, клиентов и продаж** — списки товаров по категориям, история покупок клиента и т.д.
- **Добавление и обновление данных** — формы для добавления новых клиентов, товаров и регистрации продаж.
- **Фильтрация и поиск** — функционал для поиска по товарам, поставщикам и клиентам.

Например, на языке Python и tkinter можно создать простую форму для регистрации новой продажи, включая выбор клиента и товаров из выпадающего списка.

4. **Назначение прав доступа**

Назначение прав доступа в PostgreSQL выполняется с помощью ролей и команд **GRANT** и **REVOKE**. В целях безопасности база данных торговой организации может иметь следующие роли:

- **Администратор** — имеет полные права на создание, изменение и удаление данных.
- **Менеджер** — может добавлять и обновлять данные о продажах и клиентах, но не имеет прав на удаление записей.
- **Сотрудник** — может только просматривать информацию о товарах и клиентах.

**Пример назначения прав доступа:**

```
-- Создание ролей
CREATE ROLE Администратор WITH LOGIN PASSWORD 'password';
CREATE ROLE Менеджер WITH LOGIN PASSWORD 'password';
CREATE ROLE Сотрудник WITH LOGIN PASSWORD 'password';

-- Назначение прав для каждой роли
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO Администратор;
GRANT SELECT, INSERT, UPDATE ON Товары, Клиенты, Продажи, Состав_продажи TO Менеджер;
GRANT SELECT ON Товары, Клиенты TO Сотрудник;
```

5. **Создание индексов**

Индексы необходимы для повышения скорости обработки запросов, особенно для полей, которые часто используются в фильтрации или сортировке. В PostgreSQL можно создать индексы с помощью команды **CREATE INDEX**.

Примеры создания индексов:

- **Индекс для ускорения поиска по названию товаров:**

```
CREATE INDEX idx_товары_название ON Товары (Название);
```

- **Индекс для сортировки и поиска по дате продаж:**

```
CREATE INDEX idx_продажи_дата ON Продажи (Дата_продажи);
```

- **Составной индекс для быстрого поиска по категории и цене товара:**

```
CREATE INDEX idx_товары_категория_цена ON Товары (ID_категории, Цена);
```

6. **Разработка стратегии резервного копирования базы данных**

Для защиты данных от сбоев и потерь необходимо разработать стратегию регулярного резервного копирования. Для PostgreSQL основными методами являются:

- **Ежедневное логическое резервное копирование с помощью pg_dump** — позволяет создавать бэкап базы данных в формате SQL. Эти резервные копии можно хранить на удаленном сервере или в облаке.

Пример ежедневного резервного копирования:

```
pg_dump -U username -F c -b -v -f "/backups/backup_$(date +\%Y\%m\%d).backup" database_name
```

- **Архивирование WAL-журналов** — для минимизации потерь данных в случае сбоя базы данных необходимо регулярно копировать файлы журнала WAL. Это позволит откатить базу до последнего зафиксированного состояния.

Пример настройки архивации WAL:

```
archive_mode = on
archive_command = 'cp %p /path/to/archive/%f'
```

- **Полное физическое резервное копирование раз в неделю с использованием pg_basebackup** — особенно полезно для больших объемов данных, так как обеспечивает быстрое восстановление базы данных.

Пример команды:

```
pg_basebackup -U postgres -D /path/to/backup -Ft -z -P
```

- **Проверка и тестирование восстановлений** — резервное копирование должно регулярно тестироваться на восстановление, чтобы убедиться в работоспособности резервных копий. Это критически важно для обеспечения постоянной доступности и надежности данных.

Стратегия резервного копирования должна включать хранение нескольких копий данных на случай различных инцидентов, таких как сбой оборудования или ошибка администратора.

[Вернуться к содержанию](#content)

### <a id="Conclusion">Заключение</a>

В ходе выполнения данной курсовой работы была разработана база данных для торговой организации, обеспечивающая хранение и управление данными о товарах, продажах, клиентах и поставщиках. Данная база данных является важным инструментом для упрощения процессов управления информацией и аналитики в организации, поскольку позволяет систематизировать данные и упростить доступ к ключевой информации.

На основе требований к системе была проведена аналитическая работа, включающая изучение предметной области и выявление функциональных задач, которые должна решать база данных. В результате анализа были выделены основные сущности — категории товаров, поставщики, товары, клиенты, продажи и состав продаж, — которые легли в основу концептуальной и логической моделей базы данных.

На этапе проектирования физической структуры базы данных были созданы таблицы и определены индексы для оптимизации выполнения запросов, а также разработана стратегия резервного копирования данных. Реализация проекта в среде PostgreSQL позволила создать надежную и производительную систему, готовую к интеграции в инфраструктуру торговой организации.

В ходе разработки были выполнены задачи по созданию таблиц, написанию запросов для выборки данных, организации интерфейса для взаимодействия с базой, назначению прав доступа пользователям, а также созданию резервных копий. Все это позволяет использовать разработанную систему не только для хранения данных, но и для их обработки и анализа, что будет полезно для автоматизации и повышения эффективности управления организацией.

**Реализация предложенной базы данных предоставляет торговой организации следующие преимущества:**

1. **Упрощение управления данными:** Система обеспечивает структурированное хранение информации и быстрый доступ к ней, позволяя сотрудникам эффективно выполнять свои обязанности.
2. **Аналитические возможности:** Разработанные запросы позволяют извлекать и анализировать данные о продажах, запасах товаров и взаимодействиях с клиентами, что облегчает принятие стратегических решений.
3. **Повышение надежности и безопасности данных:** Введение ролей и прав доступа, а также стратегия резервного копирования помогают защитить данные от потерь и несанкционированного доступа.

Таким образом, разработанная база данных представляет собой эффективный инструмент для торговой организации, который не только автоматизирует процессы управления данными, но и способствует улучшению качества обслуживания клиентов и оптимизации бизнес-процессов.

Руководитель работы __________________ И. В. Пунгин

Задание принял к исполнению _______________________________ А. Д. Анчиков